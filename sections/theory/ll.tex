For the construnction of a $\LLP(q,k)$ parser generator the construction of first and follow-set \cite[5]{Vagner2007} and a $\LL(k)$ parser generator is needed. A short explanation of the construction of a $\LL(k)$ parser generator will be given since in the research of this project $k = 1$ was quite often explained but never $k > 1$ in a manner the author found understandable.

The first and follow-set algorithms described takes heavy inspiration from Mogensens book Introduction to Compiler Design \cite[55-65]{Mogensen} and the parser notes \cite[10-15]{notes:parser} by Sestoft and Larsen. The modifications are mainly using the $\LL(k)$ extension described in the Wikipedia article in the section ``Constructing an LL(k) parsing table''\footnote{At the time of writing the Wikipedia article does have a description of constructing first and follow-sets for $k > 1$. The problem is the algorithm described does not fullfill the definition of first and follow-sets that is being used in the LLP paper \cite[5]{Vagner2007}.} \cite{wiki:LL_parser}.

\begin{definition}[Truncated product]
    Let $G = (N, T, P, S)$ be a context-free grammar, $A, B \in \mathbb{P}((N \cup T)^*)$ be sets of symbol strings and $\omega, \delta \in (T \cup N)^*$. The truncated product is defined in the following way.
    \begin{gather*}
        A \odot_k B \defeq \left\{\underset{\gamma \in \{\omega \, : \, \omega\delta = \alpha\beta, |\omega| \leq k\}}{\arg \max} \; |\gamma| : \alpha \in A, \beta \in B\right\}
    \end{gather*}
\end{definition}

\begin{definition}[Nonempty substring pairs]
    Let $G = (N, T, P, S)$ be a context-free grammar, $\omega \in (N \cup T)^*$ be a symbol string and $\alpha, \beta \in (N \cup T)^+$ be nonempty symbol strings. The set of every nonempty way to split $\omega$ into two substrings is defined to be.
    \begin{gather*}
        \varphi(\omega) \defeq \{(\alpha, \beta) : \alpha\beta = \omega\}
    \end{gather*}
\end{definition}

\begin{algorithm}[Solving $\FIRST_k$ set]
    \label{algorithm:first}
    Let $G = (N, T, P, S)$ be a context-free grammar, the first-sets can be solved as followed.
    \begin{align*}
        \FIRST_k(\epsilon) =&\,\, \{\epsilon\} \\
        \FIRST_k(t) =&\,\, \{t\} \\
        \FIRST_k(A) =&\,\, \bigcup_{\delta \, : \, A \to \delta \in P} \FIRST_k(\delta) \\
        \FIRST_k(\omega) =&\,\, \bigcup_{(\alpha, \beta) \, \in \, \varphi(\omega)} \FIRST_k(\alpha) \odot_k \FIRST_k(\beta)
    \end{align*}
\end{algorithm}
\noindent This may result in an infinite loop if implemented as is so fixed point iteration is used. Let $\mathcal{M}: N \to \mathbb{P}(T^*)$ be a surjective function which is used as a dictionary which maps nonterminals to sets of terminal strings. $\FIRST'_k$ is then the following modified version of $\FIRST_k$.
\begin{align*}
    \FIRST'_k(\epsilon, \mathcal{M}) =&\,\, \{\epsilon\} \\
    \FIRST'_k(t, \mathcal{M}) =&\,\, \{t\} \\
    \FIRST'_k(A, \mathcal{M}) =&\,\, \mathcal{M}(A) \\
    \FIRST'_k(\omega, \mathcal{M}) =&\,\, \bigcup_{(\alpha, \beta) \, \in \, \varphi(\omega)} \FIRST'_k(\alpha, \mathcal{M}) \odot_k \FIRST'_k(\beta, \mathcal{M})
\end{align*}
This function is then used to solve for a $\FIRST_k$ function for a fixed $k$ with fixed point iteration the following way.
\begin{enumerate}
    \item Initialize a dictionary $\mathcal{M}_0$ such that $\mathcal{M}_0(A) = \emptyset$ for all $A \in N$.
    \item A new dictionary $\mathcal{M}_{i+1}: N \to \mathbb{P}(T^*)$ is constructed by $\mathcal{M}_{i+1}(A) = \bigcup_{\delta \, : \, A \to \delta \in P} \FIRST'_k(\delta, \mathcal{M}_{i})$ for all $A \in N$ where $\mathcal{M}_{i}$ is the last dictionary that was constructed.
    \item If $\mathcal{M}_{i + 1} = \mathcal{M}_{i}$ then terminate the algorithm terminates else recompute step 2.
\end{enumerate}
Let $\mathcal{M}_f$ be the final dictionary after the algorithm terminates then it holds that $\FIRST_k(\omega) = \FIRST'_k(\omega, \mathcal{M}_f)$ if $k$ stays fixed.
\begin{algorithm}[Solving $\FOLLOW_k$ set]
    \label{algorithm:follow}
    Let $G = (N, T, P, S)$ be a context-free grammar, the follow-sets can be solved as followed.
    \begin{align*}
        \FOLLOW_k(A) &= \bigcup_{B \, : \, B \to \alpha A \beta \in P} \FIRST_k(\beta) \odot_k \FOLLOW_k(B)
    \end{align*}
\end{algorithm}
\noindent Once again this may not terminate so fixed point iteration can be used with following altered $\FOLLOW_k$ and letting $\mathcal{M}: N \to \mathbb{P}(T^*)$ be a surjective function.
\begin{align*}
    \FOLLOW_k(A, \mathcal{M}) &= \bigcup_{B \,: \, B \to \alpha A \beta \in P} \FIRST_k(\beta) \odot_k \mathcal{M}(B)
\end{align*}
This $\FOLLOW_k$ function for a fixed $k$ can then be computed using the following algorithm.
\begin{enumerate}
    \item Extend the grammar $G = (N, T, P, S)$ using $G' = (N', T', P', S') = (N \cup \{S'\}, T \cup \{\square\}, P \cup \{P \to S \square^k\}, S')$.
    \item Initialize a dictionary $\mathcal{M}_0$ such that $\mathcal{M}_0(A) = \emptyset$ for all $A \in N \backslash \{S\}$ and $\mathcal{M}_0(S) = \{\square^k\}$.
    \item A new dictionary $\mathcal{M}_{i+1}: N \to \mathbb{P}(T^*)$ is constructed by $\mathcal{M}_{i+1}(A) = \bigcup_{B \,: \, B \to  \alpha A \beta \in P} \FIRST_k(\beta) \odot_k \mathcal{M}_{i}(B)$ for all $A \in N$ where $\mathcal{M}_{i}$ is the last dictionary that was constructed.
    \item If $\mathcal{M}_{i+1} \neq \mathcal{M}_{i}$ then recompute step 3.
    \item Let $\mathcal{M}_f$ be the final dictionary after step 4. is completed. Let $\mathcal{M}_u$ be another dictionary where $\mathcal{M}_u(A) = \{\alpha : \alpha \square^* \in \mathcal{M}_f(A)\}$ for all $A \in N \backslash \{S'\}$ 
\end{enumerate}
It then holds that $\FOLLOW_k(A) = \mathcal{M}_u(A)$ if $k$ stays fixed for grammar $G$.