A method for computing admissible pairs is needed for algorithm 15 \cite[15]{Vagner2007}. These admissible pairs are substrings $x$ and $y$ such that $xy$ is infix of some string $w \in \mathcal{L}(G)$ where $G = (N, T, P, S)$ is the grammar. 

An idea is for every production $\mathcal{P} \to a_{1}a_{2}a_{3} \dots a_{n}$ where $a_i \in N \cup T$ create productions for all tails of the right-hand side i.e. the productions created from $Q_0$ are.
\begin{gather*}
    A_{0} \to a_{1}a_{2}a_{3} \dots a_{n} \qquad A_{0} \to a_{2}a_{3} \dots a_{n} \qquad A_{3} \to a_{3} \dots a_{n} \qquad A_{n} \to  a_{n}
\end{gather*}
Then for all new productions created from each existing production create a new starting nonterminal $S'$ which has all productions that leads to any nonterminal i.e.
\begin{align*}
    S' \to  \mathcal{N} \text{ where } \mathcal{N} \in N
\end{align*}
Then using $\FIRST_{q + k + 1}(S')$ and $\FOLLOW_{q + k + 1}(S')$ to construct a $\LL$ parser table. Then by creating a set of the parser tables terminal keys one is able to check if $xy$ is infix of any elements in the set.

The problem is this is slower than constructing the leftmost derivations described. This is probably because the grammar ends up getting really large so the fix point iteration of $\FIRST$ and $\FOLLOW$ becomes expensive. Also, the leftmost derivations are only constructed once so the first method are likely to be a good fit.