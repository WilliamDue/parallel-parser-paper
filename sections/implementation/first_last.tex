The $\FIRST$ implementation corresponds to algorithm \ref{algorithm:first} and the $\LAST$ implementation corresponds to the one mentioned in the LLP paper \cite[12]{Vagner2007} which uses an existing $\FIRST$ implementation. A big problem with $\FIRST$ is it is extremely expensive of the truncated product step.
\begin{align*}
    \FIRST'_k(\omega, \mathcal{M}) =&\,\, \bigcup_{(\alpha, \beta) \, \in \, \varphi(\omega)} \FIRST'_k(\alpha, \mathcal{M}) \odot_k \FIRST'_k(\beta, \mathcal{M})
\end{align*}
This inefficiency can be solved by the use of memoization since $\FIRST$ is recursively defined. In Haskell this can be done using a \lstinline{State} monad from the \lstinline{mtl} library. A problem with this is it will end up taking a lot of memory because every possible input string will be stored with its corresponding $\FIRST$ set. This does not occur in the code since the memoization is mainly used in the LLP collection. Therefore, it is bounded by the valid substrings in the grammar. The grammars used in the table generator are not grammars that creates every combination of terminals. Therefore, since this does not seem like a practical use case, this is not expected to occur practice.