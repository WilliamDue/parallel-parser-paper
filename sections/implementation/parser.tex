The parser generator creates a Futhark source file which can be used for parsing. The reason for doing so is Futhark is designed for ``parallel efficient computing''\footnote{\href{https://futhark-lang.org/}{link}} that can be executed on a GPU. Therefore the general purpose language, Haskell is used to generate the source files which contains the table parser.

The code the table generator written in Haskell does is mainly creating the table. This table is the function \lstinline{key_to_config} that patterns matches on a pair $(x, y)$ which maps to their respective configuration. These configurations do not actually correspond to an LLP configuration. Instead of using the LLP configuration $(\alpha, \omega, \pi)$ as is, the list homomorphism in algorithm 18 \cite[18]{Vagner2007} which results in the tuples $(RBR(\alpha)LBR(\omega^R), \pi)$ besides for the starting pairs $(\epsilon, \vdash w)$ where $w \in T^*$ which becomes $(LBR(\omega^R), \pi)$.

Besides this the Futhark implementation matches algorithm 18. A missing piece is the parallel bracket matching which is not described in the paper. The implementation used takes a lot of inspiration from the implementation described on the Futhark \href{https://futhark-lang.org/examples/parens.html}{website}. The differences are the balancing check is made before the grading.

Something to note is the glue \cite[7]{Vagner2007} reduce could have been used instead of algorithm 18 \cite[18]{Vagner2007}. This is a bad choice for two reasons, the first is it is slow \cite[17]{Vagner2007}. The second reason is Futhark does not have dynamic arrays and does allow for using concatenation when using the built-in \lstinline{reduce}.

It is also important to note that creating an array of strings in Futhark is also problematic task. Therefore, the terminals, nonterminals and productions are assigned an index which is used instead. 