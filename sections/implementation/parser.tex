The first problem to be concerned with is string packing. 

The code the table generator creates does is mainly creating the table. This table is the function \lstinline|key_to_config| that patterns matches on a pair $(x, y)$ which maps to their respective LLP configuration. Then to parse you would first use the \lstinline|map| the \lstinline|key_to_config| over the input string.

The first thing to note here is there are two algorithms described in the LLP paper \cite{Vagner2007} whic. 

\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
def key_to_config (key : ((u32), (u32))) : maybe ([]bracket, []u32) =
    match key
    case ((0), (1)) -> #just ([#right 5, #right 1], [3])
    case ((0), (2)) -> #just ([#right 5, #left 5], [1])
    case ((0), (3)) -> #just ([#right 5, #epsilon], [2])
    case ((2), (1)) -> #just ([#right 5, #right 1], [3])
    case ((2), (2)) -> #just ([#right 5, #left 5], [1])
    case ((2), (3)) -> #just ([#right 5, #epsilon], [2])
    case ((3), (1)) -> #just ([#right 1, #epsilon], [u32.highest])
    case ((4294967295), (0)) -> #just ([#left 1, #left 5], [0])
    case _ -> #nothing
\end{lstlisting}


These configurations do not actually correspond to an LLP configuration. Instead of using the LLP configuration $(\alpha, \omega, \pi)$ as is, the list homomorphism in algorithm 18 \cite[18]{Vagner2007} which results in the tuples $(RBR(\alpha)LBR(\omega^R), \pi)$ besides for the starting pairs $(\epsilon, \vdash w)$ where $w \in T^*$ which becomes $(LBR(\omega^R), \pi)$.



Besides this the Futhark implementation matches algorithm 18. A missing piece is the parallel bracket matching which is not described in the paper. The implementation used takes a lot of inspiration from the implementation described on the Futhark \cite{futhark:parens}. The differences are the balancing check is made before the grading and the tabulation is never done.

Something to note is the glue \cite[7]{Vagner2007} reduce could have been used instead of algorithm 18 \cite[18]{Vagner2007}. This is a bad choice for two reasons, the first is it is slow \cite[17]{Vagner2007}. The second reason is Futhark does not have dynamic arrays and does not allow for using concatenation when using the built-in \lstinline|reduce| function.

It is also important to note that creating an array of strings in Futhark is also problematic task. Therefore, the terminals, nonterminals and productions are assigned an index which is used instead. Besides this a specific integer is used to assign an empty terminal or nonterminal since a function in Futhark can not return arrays of different lengths. These empty symbols are filtered away later on.