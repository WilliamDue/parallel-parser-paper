The parser generator creates a Futhark source file which can be used for parsing. The reason for doing so is Futhark is designed for ``parallel efficient computing''\footnote{https://futhark-lang.org/} that can be executed on a GPU. Therefore the general purpose language, Haskell is used to generate the source files which contains the table parser.

The code the table generator written in Haskell does is mainly actually creating the table. This table is the function \lstinline{key_to_config} that patterns matches on a tuple of two tuples which maps to their respective configuration. These configuration do not actually correspond to an LLP configuration. Instead of using the the LLP configuration $(\alpha, \omega, \pi)$ as is the list homomorphism in algorithm 18 \cite[18]{Vagner2007} which results in the tuples $(RBR(\alpha)LBR(\omega^R), \pi)$ besides for the starting pairs $(\epsilon, \vdash w)$ where $w \in T*$ which becomes $(LBR(\omega^R), \pi)$.

Besides this the Futhark implementation matches algorithm 18. A missing piece is the parallel bracket matching which is not described in the paper. The implementation used takes a lot of inspiration from the implementation described on the Futhark \href{https://futhark-lang.org/examples/parens.html}{website}. The differences are the balancing check is made before the grading.

Something to note is the glue \cite[7]{Vagner2007} reduce could had been used instead of algorithm 18. This is a bad choice for two reasons, the first is it is slow \cite[17]{Vagner2007}. The second reason is Futhark does not have dynamic arrays and does allow for using concatenation when using the builtin \lstinline{reduce}.

It is also important to note that creating an array of strings in Futhark is also problematic task. Therefore the terminals, nonterminals andp roductions are assigned a index which is used instead. 